---
title: 设计模式 — 原型模式
date: 2022-03-31 18:35:53
tags:
- 设计模式
- design pattern
- 原型模式
category:
- 设计模式
---

原型j就是指原来的类型或模型，特指文学艺术作品中塑造人物形象所依赖的现实生活中的人

<!-- more -->

#### 原型设计模式

原型模式是一种创建型设计模式，它能够帮助你克隆指定的对象，并且无需和对象所属的类耦合，下面通过具体的问题来说明该设计模式的应用场景

#### 问题

假如现在有一个对象`User`，要复制和这个`User`完全一样的对象要怎么做呢？首先，需要新建一个同类对象，然后将`User`对象的所有成员变量复制到新对象就好了，但现在有两个问题：

1. 如果有组合类型，那就需要遍历组合类型的成员变量来完成复制；如果变量是私有变量，那么只能再调用获取私有变量的方法才能够实现私有变量的复制；

   按照这种方式进行复制的话，这段代码就和对象所属的类产生的紧密的耦合；原对象所属的类发生的任何变化，都要在此处进行相应的更改；如果这种复制代码的操作很多的话，代码就会变的很难维护了

2. 假如`User`是某个对象所实现的接口类型，就是指在某个方法中参数为接口而传入的具体对象的时候，方法中你拿到的是接口的类型，而不知道对象的具体类型，这种情况下要怎么实现复制呢？

#### 解决方法

上面的问题会在代码中引入对象所属的类，导致两者产生了紧密的耦合；原型设计模式就是将克隆的过程委派给了被克隆的实际对象，这样只需要调用该对象的克隆方法就能够实现复制，而不需要和对象所属的类耦合在一起

首先，原型设计模式为所有支持克隆的对象声明了一个通用的接口，接口中通常只有一个 `Clone()`的方法；然后，实体类实现该接口，在该方法中完成对象的复制操作；最后客户端调用的时候只需要调用该对象的`Clone()`方法就能够获取到一个和该对象相同的一个对象

所有的类对`Clone()`方法的实现都很类似；该方法首先就是创建该类的一个对象，然后将原对象的所有成员变量赋值给新的对象就好了，如果有组合类型，那么调用组合类型的`Clone()`方法就好了；按照这种方式就可以实现对私有变量的复制了

![01](./设计模式-原型模式/01.png)

支持克隆的对象就是原型对象，当你的对象有几十种成员变量和几十种组合类型时，对其进行克隆甚至能够代替子类的构造；比如：创建一系列不同类型的对象用不同的方式进行配置，如果所需对象和预先配置的对象相同，那么就可以使用`Clone()`方法进行构造

#### 原型设计模式代码示例

```go
package main

import (
	"fmt"
	"reflect"
)

type Prototype interface {
	Clone() Prototype
}

type Car struct {
	Name  string
	Color string
	Age   int
	Kind  string
	which string
}

func (c *Car) Clone() Prototype {
	newCar := &Car{
		Name:  c.Name,
		Color: c.Color,
		Age:   c.Age,
		Kind:  c.Kind,
		which: c.which,
	}
	return newCar
}

func main() {
	c := &Car{
		Name:  "BB",
		Color: "White",
		Age:   1,
		Kind:  "BA",
		which: "Me",
	}
	fmt.Println(&c)
	cc := c.Clone()
	fmt.Println(reflect.TypeOf(cc))
	fmt.Println(cc)
	fmt.Println(&cc)
}
```

#### 原型注册表

原型注册表就是将所有的原型对象存储起来，然后提供一种访问原型对象的方法；比如：可以使用`HashMap`作为存储，然后将对象的名称作为`key`，对象实例作为值存储起来；使用的时候通过对象的名称就可以获取到原型对象了

#### 适用场景

###### 独立于当前代码

假如当前代码中需要复制一些对象，同时又希望代码能够独立于这些对象所属的类，则就可以使用原型设计模式；

原型设计模式提供了一个通用的接口，客户端通过使用这一个通用的接口来完成与克隆对象的交互，使得客户端代码与其克隆对象的类独立开

###### 初始化子类

如果子类的区别仅在于其对象的初始化方式，那就可以使用该类来减少子类的数量。因为别人创建这些子类的目的就是为了创建特定类型的对象；在原型模式中，可以使用一系列预生成的，各种类型的对象作为原型；客户端就不需要对子类进行初始化了，只需要找到合适的原型进行克隆就好了